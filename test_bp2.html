<!DOCTYPE html>
<meta charset="utf-8">
<style> /*
body{ 
	width:1200px;
	margin:100px auto;
}
svg text{
	font-size:8pt;
}
rect{
	shape-rendering:crispEdges;
}

.brush .extent {
  fill-opacity: .1;
  stroke: #fff;
  shape-rendering: crispEdges;
}
*/
.node circle {
   cursor: pointer;
   fill: #fff;
   stroke: steelblue;
   stroke-width: 1.5px;
}
.node text {
   font-size: 11px;
}
path.link {
   fill: none;
   stroke: #ccc;
   stroke-width: 1.5px;
}
#csvdata {
   display: none;
}
#taxTree{
	float:left;
}
#bpGraph{
	float:left;
}
#funcTree{
	float:left;
}
</style>
<body>
<div id="taxTree">
</div>
<div id="bpGraph">
	</div>
<div id="funcTree">
</div>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="data_cube.js"></script>
<script src="bp2.js"></script>
<script>


var width = 400, height = 610, margin ={b:0, t:40, left:30, right:30, top:10, bottom:10};

var i = 0,
    duration = 750,
    taxaroot,
	funcroot,
	roots = {};

var TaxaTree = d3.layout.tree()
    .children(function (d) {
    if (d.hasOwnProperty('values')) return d.values;
    else if (d.hasOwnProperty('children')) return d.children;
})
    .size([height, width/2]);

var FuncTree = d3.layout.tree()
    .children(function (d) {
    if (d.hasOwnProperty('values')) return d.values;
    else if (d.hasOwnProperty('children')) return d.children;
})
    .size([height, width/2]);

var trees = [];
trees["taxa"] = TaxaTree;
trees["func"] = FuncTree;

var diagonal = d3.svg.diagonal()
    .projection(function (d) {
    return [d.y, d.x];
});

var TaxaTreeSVG = d3.selectAll("#taxTree").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var FuncTreeSVG = d3.select("#funcTree").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var SVGs = {};
SVGs["taxa"] = TaxaTreeSVG;
SVGs["func"] = FuncTreeSVG;

  d3.tsv("reduced_genus_pathway_metagenome_contributions.txt", function(error, contribution_data) {
    d3.tsv("taxa_mapping2.txt", function(error, taxa_tree_data){
      d3.tsv("function_mapping2.txt", function(error, func_tree_data){
        d3.tsv("reduced_pathway_functions_transpose.txt", function(error, func_rel_abundance_data){
				//initialize display cube
				var data_cube = data_cube_wrapper.make_cube();
				data_cube.initialize_cube(contribution_data, taxa_tree_data, func_tree_data, func_rel_abundance_data);
				data_cube.expand_taxon('Bacteria');
				data_cube.expand_func("Cellular Processes");
				data_cube.collapse_taxon("Bacteria");
				data_cube.collapse_func("Cellular Processes");

				var svg = d3.select("#bpGraph")
					.append("svg").attr('width',width).attr('height',(height+margin.b+margin.t))
					.append("g").attr("transform","translate("+ margin.l+","+margin.t+")");

				getLinkData = function(){
					//get unique linked functions for each taxon
					allSamples = d3.keys(data_cube.displayed_contribution_cube);
					var all_taxa_links = []; //{Taxa:[], Functions:[]};
					allSamples.map(function(d){
						(data_cube.displayed_taxa).map(function(t,i){
							if(all_taxa_links.map(function(d){return d.Taxa;}).indexOf(t)===-1){
							if((data_cube.displayed_contribution_cube[d]).hasOwnProperty(t)){
								for(j=0; j<data_cube.displayed_funcs.length; j++){
									if(data_cube.displayed_contribution_cube[d][t].hasOwnProperty(data_cube.displayed_funcs[j])){
										all_taxa_links.push({Taxa:t, Functions:data_cube.displayed_funcs[j],
										numKO:1});
									}
								}
									//all_taxa_links.Functions.push(d3.keys(data_cube.displayed_contribution_cube[d][t])[j]);
							}
							}
						});
					});
					return all_taxa_links;
					//a.filter(function(item, i, ar){ return ar.indexOf(item) === i; });
				}

				//console.log(data_cube.displayed_contribution_cube[d3.keys(data_cube.displayed_contribution_cube)[0]].toSource());
				var taxLevels = d3.keys(taxa_tree_data[0]);

				var bpData = getLinkData();

				var data = {data:bP.partData(bpData), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
				bP.draw(data, svg);
				//data_cube.expand_taxon("Bacteria");
				//data_cube.expand_func("Metabolism");
				var bpData = getLinkData();
				var data = {data:bP.partData(bpData), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
				bP.updateGraph(data, svg);

				var taxa_data = d3.nest()
			        .key(function(d) { return d.Kingdom; })
			        .key(function(d) { return d.Phylum; })
			        .key(function(d) { return d.Class; })
			        .key(function(d) { return d.Order; })
			        .key(function(d) { return d.Family; })
			        .key(function(d) { return d.Genus; })
			        .entries(taxa_tree_data);    

			    newTaxaData = {
			        "name": "All Taxa",
			        "children": taxa_data,
			    }

			    taxaroot = newTaxaData;
			    taxaroot.x0 = height/2;
			    taxaroot.y0 = 0;
				
			    function collapse(d) {
					d.type = settype;
			        if (d.hasOwnProperty('name')) {
			            if (d.children) {
			                d._children = d.children;
			                d._children.forEach(collapse);
			                d.children = null;
			            }
			        } else if (d.hasOwnProperty('key')) {
			            if (d.values) {
			                d._values = d.values;
			                d._values.forEach(collapse);
			                d.values = null;
			            }
			        }
			    }
				
				var settype = 'taxa';
			    taxaroot.children.forEach(collapse);
				taxaroot.type = 'taxa';

				roots["taxa"] = taxaroot;
				
			    update(taxaroot);

			    d3.select(self.frameElement).style("height", "800px");

			    var function_data = d3.nest()
			        .key(function(d) { return d.Category; })
			        .key(function(d) { return d.SuperPathway; })
			        .key(function(d) { return d.SubPathway; })
			        .entries(func_tree_data);    

			    newFunctionData = {
			        "name": "All Functions",
			        "children": function_data,
			    }

			    funcroot = newFunctionData;
			    funcroot.x0 = height/2;
			    funcroot.y0 = 0;
				settype = 'func';
			    funcroot.children.forEach(collapse);
				funcroot.type = settype;
				roots["func"] = funcroot;
				
			    update(funcroot);

			    d3.select(self.frameElement).style("height", "800px");

			        function update(source) {

        // Compute the new tree layout.
		
        var nodes = trees[source.type].nodes(roots[source.type]).reverse(),
            links = trees[source.type].links(nodes);
		
		var nleaf = 0;
		nodes.forEach(function (d) {
			nleaf = nleaf + (d.children || d.values ? 0 : 1);
		})
		
		var leafC = 1;
		nodes.forEach(function (d) {
			if (!(d.children || d.values)) {
				d.x = (nleaf - leafC)/nleaf * height;
				leafC = leafC + 1;
			} else {
				var sumpos = 0;
				d.children.forEach(function (dc) {
					sumpos = sumpos + dc.x;
				})
				d.x = sumpos / d.children.length;
			}
		})
        // Normalize for fixed-depth.
		var maxDepth = getDepth(roots[source.type]);
        nodes.forEach(function (d) {
			if (source.type == 'taxa') {
				d.y = (d.depth / maxDepth) * width ;
			} else {
				d.y = width - (d.depth / maxDepth) * width;
			}
            
        });

        // Update the nodes…
        var node = SVGs[source.type].selectAll("g.node")
            .data(nodes, function (d) {
            return d.id || (d.id = ++i);
        });

        // Enter any new nodes at the parent's previous position.
        var nodeEnter = node.enter().append("g")
            .attr("class", "node")
            .attr("transform", function (d) {
            return "translate(" + source.y0 + "," + source.x0 + ")";
        })
            .on("click", click);

        nodeEnter.append("circle")
            .attr("r", 1e-6)
            .style("fill", function (d) {
            return d._children || d._values ? "lightsteelblue" : "#fff";
        });

        nodeEnter.append("text")
            .attr("x", function (d) {
            return source.type == 'taxa' ? 10 : -10;
        })
            .attr("dy", ".35em")
            .attr("text-anchor", function (d) {
            return source.type == 'taxa' ? "start" : "end";
        })
            .text(function (d) {
               if(d.name != null)
                   return d.name;
               else if(d.key != null)
                   return d.key;
        })
            .style("fill-opacity", 1e-6);

        // Transition nodes to their new position.
        var nodeUpdate = node.transition()
            .duration(duration)
            .attr("transform", function (d) {
            return "translate(" + d.y + "," + d.x + ")";
        });

        nodeUpdate.select("circle")
            .attr("r", 4.5)
            .style("fill", function (d) {
            return d._children || d._values ? "lightsteelblue" : "#fff";
        });

        nodeUpdate.select("text")
            .style("fill-opacity", function(d) {
				return d.children || d.values ? 0 : 1;
			})
			.text(function (d) {
				if(d.children || d.values) {
					return "";
				} else {
					if(d.name != null)
                   return d.name;
               else if(d.key != null)
                   return d.key;
				}
			});

        // Transition exiting nodes to the parent's new position.
        var nodeExit = node.exit().transition()
            .duration(duration)
            .attr("transform", function (d) {
            return "translate(" + source.y + "," + source.x + ")";
        })
            .remove();

        nodeExit.select("circle")
            .attr("r", 1e-6);

        nodeExit.select("text")
            .style("fill-opacity", 1e-6);

        // Update the links…
        var link = SVGs[source.type].selectAll("path.link")
            .data(links, function (d) {
            return d.target.id;
        });

        // Enter any new links at the parent's previous position.
        link.enter().insert("path", "g")
            .attr("class", "link")
            .attr("d", function (d) {
            var o = {
                x: source.x0,
                y: source.y0
            };
            return diagonal({
                source: o,
                target: o
            });
        });

        // Transition links to their new position.
        link.transition()
            .duration(duration)
            .attr("d", diagonal);

        // Transition exiting nodes to the parent's new position.
        link.exit().transition()
            .duration(duration)
            .attr("d", function (d) {
            var o = {
                x: source.x,
                y: source.y
            };
            return diagonal({
                source: o,
                target: o
            });
        }).remove();

        // Stash the old positions for transition.
        nodes.forEach(function (d) {
            //console.log(d.x);
            //console.log(d.y);
            d.x0 = d.x;
            d.y0 = d.y;
        });
    }

	// Update the bipartite graph after changes to data_cube
	function updateBPgraph() {
		var bpData = getLinkData();
		var data = {data:bP.partData(bpData), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
		bP.updateGraph(data, svg);
	}
	
    // Toggle children on click.
    function click(d) {
        if (d.hasOwnProperty('name')) {
            if (d.children) {
                d._children = d.children;
                d.children = null;
				d.type == 'taxa' ? data_cube.collapse_taxon(d.name) : data_cube.collapse_func(d.name);
				updateBPgraph();
            } else {
                d.children = d._children;
                d._children = null;
				d.type == 'taxa' ? data_cube.expand_taxon(d.name) : data_cube.expand_func(d.name);
				updateBPgraph();
            }
        } else if (d.hasOwnProperty('key')) {
            if (d.values) {
                d._values = d.values;
                d.values = null;
				d.type == 'taxa' ? data_cube.collapse_taxon(d.key) : data_cube.collapse_func(d.key);
				updateBPgraph();
            } else {
                d.values = d._values;
                d._values = null;
				d.type == 'taxa' ? data_cube.expand_taxon(d.key) : data_cube.expand_func(d.key);
				updateBPgraph();
            }
        }
        update(d);
    }
	
	function getDepth(rootnode) {
		var depth = 0;
		if (rootnode.children) {
			rootnode.children.forEach(function(d) {
				var tmpDepth = getDepth(d);
				if (tmpDepth > depth) {
					depth = tmpDepth;
				}
			})
		}
		return 1+depth;
	}
	
	function showInfo(d) {
		
	}


		});
    });
  });
});

</script>
</body>