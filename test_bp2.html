	<!DOCTYPE html>
<meta charset="utf-8">
<style> /*
body{ 
	width:1200px;
	margin:100px auto;
}
svg text{
	font-size:8pt;
}
rect{
	shape-rendering:crispEdges;
}

.brush .extent {
  fill-opacity: .1;
  stroke: #fff;
  shape-rendering: crispEdges;
}
*/
.node circle {
   cursor: pointer;
   fill: #fff;
   stroke: steelblue;
   stroke-width: 1.5px;
}
.node text {
   font-size: 11px;
}
path.link {
   fill: none;
   stroke: #ccc;
   stroke-width: 1.5px;
}

body{
    font-family: "Verdana", Verdana, sans-serif;
    font-size:12px;
}

#csvdata {
   display: none;
}
#taxTree{
	float:left;
}
#bpGraph{
	float:left;
}
#funcTree{
	float:left;
}
#navgraph{
	float:top;
	}
white-space: pre-line;
</style>
<head>
<div style="float:left">
<h2>Exploring microbial community taxa and functions</h2>
<h4>Click on nodes of the tree to see more details about a taxon or function. Mouse over any taxon or function to see its relationships and contributions across samples. </h4>
<p>Alex Eng, Will Gagne-Maynard, Colin McNally, Cecilia Noecker</p>
<p> data from Theriot et al <i>Nature Communications</i> (2014)</p>
</div>
<button type="button" onclick = "hideheader()" style="float:right">Hide Header</button>
</head>
<body>
<div id="navgraph">   </div>
<div id="barsgraph">   </div>
<!--script src="http://d3js.org/d3.v3.min.js"-->
<script src="Javascript/d3.v3.min.js"></script>
<script src="Javascript/data_cube.js"></script>
<script src="Javascript/bp2.js"></script>
<script src="Javascript/FuncBar.js"></script>
<script src="Javascript/otu_stacked_bar.js"></script>
<script>



var width = 1200, height = 400, margin ={left:40, right:40, top:50, bottom:10 , barleft:60, bartop:10, barbottom:80, betwbars:70};
var barDimensions = {width: (width / 2 - margin.betwbars), height:height };
var bpdims = {height: height};
var treewidth = width / 3;
var i = 0,
    duration = 300,
    taxaroot,
	funcroot,
	roots = {};

var TaxaTree = d3.layout.tree()
    .children(function (d) { return d.values; })
    .size([height, treewidth*2/3]);

var FuncTree = d3.layout.tree()
    .children(function (d) { return d.values;})
    .size([height, treewidth*2/3]);

var trees = [];
trees["taxa"] = TaxaTree;
trees["func"] = FuncTree;

var diagonal = d3.svg.diagonal()
    .projection(function (d) {
    return [d.y, d.x];
});

var NavSVG = d3.select("#navgraph").append("svg")
	.attr("id","navsvg")
	.attr('width',(margin.left + width + margin.right))
	.attr('height',(margin.bottom + height + margin.top));

var bpG = NavSVG.append("g")
	.attr("transform","translate("+ (margin.left * 2 + treewidth) +","+ margin.top +")");
	
var TaxaTreeG = NavSVG.append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");
	

var FuncTreeG = NavSVG.append("g")
    .attr("transform", "translate(" + (margin.left + treewidth*2) + "," + margin.top + ")");

var BarSVG = d3.select("#barsgraph").append("svg")
	.attr("width", (margin.barleft + width + margin.right))
	.attr("height", (margin.barbottom + height + margin.bartop));

var TaxaBar = BarSVG.append("g")
	.attr("transform", "translate(" + margin.barleft + "," + margin.bartop + ")")
	.attr("id", "taxa_bars");

var FunctionBar = BarSVG.append("g")
	.attr("transform", "translate(" + (margin.barleft + barDimensions.width + margin.betwbars) + "," + margin.bartop + ")")
	.attr("id", "func_bars");



var bpvisdata;

var SVGs = {};
SVGs["taxa"] = TaxaTreeG;
SVGs["func"] = FuncTreeG;

var levelNames = {};
var curlevelNames = {};
levelNames['taxa'] = ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus"];
levelNames['func'] = ["Category", "SuperPathway", "SubPathway"];
curlevelNames['taxa'] = levelNames['taxa'];
curlevelNames['func'] = levelNames['func'];

d3.tsv("Data/reduced_genus_pathway_metagenome_contributions.txt", function(error, contribution_data) {
    d3.tsv("Data/taxa_mapping2.txt", function(error, taxa_tree_data){
		d3.tsv("Data/function_mapping2.txt", function(error, func_tree_data){
			d3.tsv("Data/reduced_pathway_functions_transpose.txt", function(error, func_rel_abundance_data){
				d3.tsv("Data/mice_samplemap.txt", function(error, samplemap){
					d3.tsv("Data/reduced_genus_taxa_transpose.txt", function(error, otu_abundance_data){

						var taxa_colors = d3.scale.category20();
						var func_colors = d3.scale.category20();

						//initialize display cube
						var data_cube = data_cube_wrapper.make_cube();
						data_cube.initialize_cube(contribution_data, taxa_tree_data, func_tree_data, func_rel_abundance_data);

						
						getLinkData = function(){
							//get unique linked functions for each taxon
							allSamples = d3.keys(data_cube.displayed_contribution_cube);
							var all_taxa_links = []; //{Taxa:[], Functions:[]};
							data_cube.displayed_taxa.map(function(t,i){
								data_cube.displayed_funcs.map(function(f,i){
									var foo = allSamples.map(function(d){
										return data_cube.get_contribution(d,t,f);
									})
									if(d3.sum(foo)!==0){
										all_taxa_links.push({Taxa:t, Functions:f, numKO:1});
									}
								})
							});
							return all_taxa_links;
						}

						//this gets the data for the functional bar chart

						getFuncBarData = function(){
							var contributions = [];
							var samples = [];
							var funcs = [];
							var taxa = [];

							var all_func_data = [];
							var count = 0;
							var tcount = 0;

							allSamples = d3.keys(data_cube.displayed_contribution_cube).sort();
							var all_taxa_links = []; //{Taxa:[], Functions:[]};
							//loop through all the functions
							//this keeps all functions together

							//loop through Samples, funcs and taxa and create arrays of the data
							allSamples.map(function(d){	
								samples.push({sample:d});
							});
							var my_displayed_funcs = data_cube.displayed_funcs.slice(0);
							my_displayed_funcs.reverse();
							(my_displayed_funcs).map(function(z){
								funcs.push(z);
							});
							var my_displayed_taxa = data_cube.displayed_taxa.slice(0);
							my_displayed_taxa.reverse();
							(my_displayed_taxa).map(function(t,i){
								taxa.push(t)
							});
							//then loop through sequentially to populate an array of all the samples
							samples.map(function(n){
								funcs.map(function(m){

									taxa.map(function(tt){	
										contributions.push({func:m, Taxa:tt, Sample:n.sample, contributions:data_cube.get_contribution([n.sample],[tt],[m])});})
								})
							var temp = [];
							contributions.map(function(q){
								if (q.Sample == n.sample) {
									temp.push({func:q.func, Taxa:q.Taxa, Sample:q.Sample, contributions:q.contributions});}
							})

							all_func_data.push({data:temp, Sample:n.sample});
							count = count + 1
							});
							return all_func_data;
						}

						function sort_nest(x, y){
							if (x.key < y.key){
								return -1;
							} else if (x.key > y.key){
								return 1;
							} else {
								return 0;
							}
						}

						//console.log(data_cube.displayed_contribution_cube[d3.keys(data_cube.displayed_contribution_cube)[0]].toSource());
						var taxLevels = d3.keys(taxa_tree_data[0]);
						//data_cube.expand_taxon("Bacteria");

						var bpData = getLinkData();
						var data = {data:bP.partData(bpData, data_cube.displayed_taxa, data_cube.displayed_funcs), id:'Genomes', header:["Taxa","Functions", "Genomes"]};


						//draw the stacked bar

						var stackData = getFuncBarData();

						fB.Draw(stackData, samplemap, func_colors, FunctionBar, barDimensions, highlightOverall, dehighlightOverall);

						var otu_bar_data = otu_bar.make_data(otu_abundance_data, data_cube);
						otu_bar.draw(otu_bar_data, samplemap, taxa_colors, TaxaBar, barDimensions, highlightOverall, dehighlightOverall);


						bP.draw(data, bpG, bpdims, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs,highlightOverall, dehighlightOverall);


						function update_otu_bar(){
							//remove old graph before redrawing new
							TaxaBar.selectAll("g").remove();
							otu_bar_data = otu_bar.make_data(otu_abundance_data, data_cube);

							otu_bar.draw(otu_bar_data, samplemap, taxa_colors, TaxaBar, barDimensions, highlightOverall, dehighlightOverall);
						}

						function update_func_bar(){
							//remove old graph before redrawing new
								FunctionBar.selectAll("g").remove();
								var func_data = getFuncBarData();
								fB.Draw(func_data, samplemap, func_colors, FunctionBar, barDimensions, highlightOverall, dehighlightOverall);

						}

						//data_cube.expand_func("Metabolism");
						var bpData = getLinkData();
						var data = {data:bP.partData(bpData, data_cube.displayed_taxa, data_cube.displayed_funcs), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
						bpvisdata = bP.updateGraph(data, bpG, bpdims, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs, highlightOverall, dehighlightOverall);

						var taxa_data = d3.nest()
					        .key(function(d) { return d.Kingdom; })
					        .key(function(d) { return d.Phylum; })
					        .key(function(d) { return d.Class; })
					        .key(function(d) { return d.Order; })
					        .key(function(d) { return d.Family; })
					        .key(function(d) { return d.Genus; })
					        .entries(taxa_tree_data);    

							
					    var curr_taxa = [];
					    for (var i = 0; i < taxa_data.length; i++){
						    curr_taxa.push(taxa_data[i]);
						}
					    for (; curr_taxa.length > 0;){
					    	curr_taxon = curr_taxa.shift();
					    	if (!data_cube.is_leaf(curr_taxon)){
					    		curr_taxon.values.sort(sort_nest);
					    		for (var i = 0; i < curr_taxon.values.length; i++){
					    			curr_taxa.push(curr_taxon.values[i]);
					    		}
					    	}
					    }

					    newTaxaData = {
					        "key": "All Taxa",
					        "values": taxa_data,
					    }

					    taxaroot = newTaxaData;
					    taxaroot.x0 = height/2;
					    taxaroot.y0 = 0;
						
					    function collapse(d) {
							d.type = settype;
					            if (d.values) {
					                d._values = d.values;
					                d._values.forEach(collapse);
					                d.values = null;
					            }
					        
					    }
						
						var settype = 'taxa';
					    taxaroot.values.forEach(collapse);
						taxaroot.type = 'taxa';

						function countchildren(rootnode) {
							var totchildren = 0;
							var addone = 1;
							if (rootnode.values) {
								rootnode.values.forEach( function(d) {
									totchildren = totchildren + countchildren(d);
								})
								addone = 0;
							} 
							if (rootnode._values) {
								rootnode._values.forEach( function(d) {
									totchildren = totchildren + countchildren(d);
								})
								addone = 0;
							}
							rootnode.Ndescendents = totchildren;
							return (totchildren + addone);
						}
						
						
						roots["taxa"] = taxaroot;
						countchildren(roots["taxa"]);
					    update(roots["taxa"]);

					    d3.select(self.frameElement).style("height", "800px");

					    var function_data = d3.nest()
					        .key(function(d) { return d.Category; })
					        .key(function(d) { return d.SuperPathway; })
					        .key(function(d) { return d.SubPathway; })
					        .entries(func_tree_data);  

					    var curr_funcs = [];
					    for (var i = 0; i < function_data.length; i++){
						    curr_funcs.push(function_data[i]);
						}
					    for (; curr_funcs.length > 0;){
					    	curr_func = curr_funcs.shift();
					    	if (!data_cube.is_leaf(curr_func)){
					    		curr_func.values.sort(sort_nest);
					    		for (var i = 0; i < curr_func.values.length; i++){
					    			curr_funcs.push(curr_func.values[i]);
					    		}
					    	}
					    }  

					    newFunctionData = {
					        "key": "All Functions",
					        "values": function_data,
					    }

					    funcroot = newFunctionData;
					    funcroot.x0 = height/2;
					    funcroot.y0 = 0;
						
						settype = 'func';
					    funcroot.values.forEach(collapse);
						funcroot.type = settype;
						
						roots["func"] = funcroot;
						countchildren(roots["func"]);
					    update(roots['func']);

					    d3.select(self.frameElement).style("height", "800px");
						
												
						// Update the tree graphs
						// Expands or collapses the source node, depending on whether it is currently open or closed
						function update(source) {
							// Compute the new tree layout.
							var nodes = trees[source.type].nodes(roots[source.type]).reverse(),
								links = trees[source.type].links(nodes);
								

							var nleaf = 0;
							nodes.forEach(function (d) {
								nleaf = nleaf + (d.values ? 0 : 1);
							})
							/*
							//console.log(nleaf);
							
							var leafC = 1;
							*/
							nodes.forEach(function (d) {
								if (!(d.values)) { 
									var dattype = d.type == "taxa" ? 0 : 1;
									var thedat = -1;

									for (var idxz = 0; idxz < bpvisdata.keys[dattype].length ; idxz++) {
										if (d.key == bpvisdata.keys[dattype][idxz])
											thedat = idxz;
									}
									
									if (thedat >= 0) {
										d.x = bpvisdata.mainBars[dattype][thedat].y;	
									} else { d.x = 0; 
									}
									
									//d.x = (nleaf - leafC)/nleaf * height;
									//leafC = leafC + 1;
								} else { 
									var sumpos = 0;
									d.values.forEach(function (dc) {
										sumpos = sumpos + dc.x;
									})
									d.x = sumpos / d.values.length; 
								}
							})
							
							
							// Normalize for fixed-depth.
							var maxDepth = getDepth(roots[source.type]);
							
							var depthpos = {};
							depthpos['taxa'] = [];
							depthpos['func'] = [];
							nodes.forEach(function (d) {
								if (source.type == 'taxa') {
									//d.y = (d.depth / maxDepth) * treewidth ;
									if (d.depth == maxDepth) {
										//d.y = treewidth;
									}
									depthpos['taxa'][d.depth] = d.y;

								} else {
									//d.y = treewidth - (d.depth / maxDepth) * treewidth;
									d.y = treewidth - d.y;
									depthpos['func'][d.depth] = d.y;
								}
							}); 

							// figure out which depth levels exist
							curlevelNames[source.type] = [];
							for (idxz = 0; idxz < (maxDepth - 1); idxz++) {
								curlevelNames[source.type].push({name: levelNames[source.type][idxz], depth: idxz});
							}
							
							// Update the tree depth labels
							var depthlabels = SVGs[source.type].selectAll("g.depthlabel")
								.data(curlevelNames[source.type])
								
							var newdepthlabels = depthlabels.enter().append("g")
								.attr("class","depthlabel")
								.attr("transform", function(d) {
									return "translate(" + depthpos[source.type][d.depth+1] + "," + -15 + ") rotate(" + (source.type == 'taxa' ? -35 : 35) + ")" ;
								});
								
							newdepthlabels.append("text")
								.text(function (d) {
									return d.name;
									})
								.style("font-weight","bold")
								.attr("text-anchor","middle")
								.attr("visibility", "hidden");
								
							var upddepthlabels = depthlabels.transition()
								.duration(duration)
								.style("font-weight","bold")
								.attr("transform", function(d) {
									return "translate(" + depthpos[source.type][d.depth+1] + "," + -15 + ") rotate(" + (source.type == 'taxa' ? -35 : 35) + ")";
								});
								
							upddepthlabels.select("text")
								.attr("visibility", "visible");
							
							var labelexit = depthlabels.exit().transition()
								.duration(duration)
								.remove();
								
							labelexit.select("text")
								.attr("visibility","hidden");
								
							
								
							
							// Update the nodes…
							var node = SVGs[source.type].selectAll("g.node")
								.data(nodes, function (d) {
								return d.id || (d.id = ++i);
							});

							// Enter any new nodes at the parent's previous position.
							var nodeEnter = node.enter().append("g")
								.attr("class", "node")
								.attr("transform", function (d) {
									return "translate(" + source.y0 + "," + source.x0 + ")";
								})
								.on("click", click)
								.on("mouseover", function (d) {
									if (~d.values) {
										if (d.type == 'taxa') {
											highlightOverall(d.key, "", 1);
										} else {
											highlightOverall("", d.key, 2);
										}
									} else {
										highlightTree(d, this);
									}
																	

								})
								.on("mouseout", function(d) {
									if (~d.values) {
										if (d.type == 'taxa') {
											dehighlightOverall(d.key, "", 1);
										} else {
											dehighlightOverall("", d.key, 2);
										}
									} else {
										dehighlightTree(d, this);
									}

									
									// var selectedBar = d3.select("#Genomes").select(".part"+m).select(".mainbars")
									// 	.selectAll(".mainbar").filter(function(f,i){ 
									// 	return (i== displayed.indexOf(d.key));}); //return sth element of main bar only
			

									// var selSubBar = d3.select("#Genomes").select(".part"+m).select(".subbars").selectAll(".subbar")
									// 	.filter(function(f,i){ return (f["key"+(m+1)]==displayed.indexOf(d.key)); }); //return sth element of main bar only
									// selSubBar.style("opacity", 0.1);

									// //selectedBar.select(".mainrect").style("stroke-opacity",0);			
									// selectedBar.select(".barlabel").style('font-weight','normal')//.style("visibility", "hidden");

									// var selectedEdges = d3.select("#Genomes").select(".edges").selectAll(".edge")
									// 	.filter(function(f,i){ return (f["key"+(m+1)]==displayed.indexOf(d.key)); });
									// //console.log(selectedEdges.toSource());

									// selectedEdges.attr("points", bP.edgePolygon).style("opacity", 0.2);


									});

							nodeEnter.filter( function(d) { return (~d.values) }).append("rect")
								.attr("x", function (d) {
									if (source.type == 'taxa') {
										return 0; 
									} else {
										return (-170 - d.y);
									}})
								.attr("width", function(d) {
									if (source.type == 'taxa') {
										return "" + (treewidth + margin.left - d.y) + ""
									} else {
										return 170+d.y;
									}})
								.attr("height", function(d) {
									return (height / nleaf / 1.5);
									})
								.attr("y", function (d) {
									return (-1 * height / nleaf / 3); })
								.attr("style","opacity:0")
								;
							
							nodeEnter.append("circle")
								.attr("r", 1e-6)
								.style("fill", function (d) {
								return d._values ? "lightsteelblue" : "#fff";
							});
							
							node.filter( function (d) {
								return (~d.values) })
									.filter( function(d) { return d3.select(this).select("rect").empty(); })
									.append("rect");

							/*
							nodeEnter.append("text")
								.attr("x", function (d) {
								return source.type == 'taxa' ? 10 : -10;
							})
								.attr("dy", ".35em")
								.attr("text-anchor", function (d) {
								return source.type == 'taxa' ? "start" : "end";
							})
								.text(function (d) {
								   if(d.key != null)
									   return d.key;
							})
								.style("fill-opacity", 1e-6);
							*/
							
							// Transition nodes to their new position.
							var nodeUpdate = node.transition()
								.duration(duration)
								.attr("transform", function (d) {
								return "translate(" + d.y + "," + d.x + ")";
							}); 

							nodeUpdate.filter( function (d) {return (d.values) } ).selectAll("rect").remove();
							
							
									
							nodeUpdate.selectAll("rect")
								.attr("x", function (d) {
									if (source.type == 'taxa') {
										return 0; 
									} else {
										return (-170 - d.y);
									}})
								.attr("width", function(d) {
									if (source.type == 'taxa') {
										return "" + (treewidth + margin.left - d.y) + ""
									} else {
										return 170+d.y;
									}})
								.attr("height", function(d) {
									return (height / nleaf / 1.5);
									})
								.attr("y", function (d) {
									return (-1 * height / nleaf / 3); })
								.attr("style","opacity:0")
								;
							
							
							nodeUpdate.select("circle")
								.attr("r", function (d) {
									if(d._values){
										return (4 * Math.sqrt(d.Ndescendents))
									}else{
										return 4;
									}
								})
								.style("fill", function (d) {
									if (d.values) {
									return "#fff";
									} else {  // has d._values
										if (d._values[0].hasOwnProperty("key")) {
											return "lightsteelblue";
										} else {
											return "#000"
										}
									}
								});

							/*
							nodeUpdate.select("text")
								.style("fill-opacity", function(d) {
									return d.values ? 0 : 1;
								})
								.text(function (d) {
									if( d.values) {
										return "";
									} else {
										if(d.key != null)
									   return d.key;
									}
								}); */
								
								

							// Transition exiting nodes to the parent's new position.
							var nodeExit = node.exit().transition()
								.duration(duration)
								.attr("transform", function (d) {
								return "translate(" + source.y + "," + source.x + ")";
							})
								.remove();

							nodeExit.select("circle")
								.attr("r", 1e-6);

						/*	nodeExit.select("text")
								.style("fill-opacity", 1e-6); */

							
							// Update the links…
							var link = SVGs[source.type].selectAll("path.link")
								.data(links, function (d) {
								return d.target.id;
							});

							// Enter any new links at the parent's previous position.
							link.enter().insert("path", "g")
								.attr("class", "link")
								.attr("d", function (d) {
								var o = {
									x: source.x0,
									y: source.y0
								};
								return diagonal({
									source: o,
									target: o
								});
							});

							// Transition links to their new position.
							link.transition()
								.duration(duration)
								.attr("d", diagonal);

							// Transition exiting nodes to the parent's new position.
							link.exit().transition()
								.duration(duration)
								.attr("d", function (d) {
								var o = {
									x: source.x,
									y: source.y
								};
								return diagonal({
									source: o,
									target: o
								});
							}).remove();

							// Stash the old positions for transition.
							nodes.forEach(function (d) {
								//console.log(d.x);
								//console.log(d.y);
								d.x0 = d.x;
								d.y0 = d.y;
							});
							
					/////////////////////// Do depth labels /////////////////////////////
							// figure out which depth levels exist
							curlevelNames[source.type] = [];
							for (idxz = 0; idxz < (maxDepth - 1); idxz++) {
								curlevelNames[source.type].push({name: levelNames[source.type][idxz], depth: idxz});
							}
							//console.log(curlevelNames[source.type][source.type]);
							
							// Update the tree depth labels
							var depthlabels = SVGs[source.type].selectAll("g.depthlabel")
								.data(curlevelNames[source.type])
								
							var newdepthlabels = depthlabels.enter().append("g")
								.attr("class","depthlabel")
								.attr("transform", function(d) {
									return "translate(" + depthpos[source.type][d.depth+1] + "," + -15 + ") rotate(" + (source.type == 'taxa' ? -35 : 35) + ")" ;
								});
								
							newdepthlabels.append("text")
								.text(function (d) {
									return d.name;
									})
								.style("font-weight","bold")
								.attr("text-anchor","middle")
								.attr("visibility", "hidden");
								
							var upddepthlabels = depthlabels.transition()
								.duration(duration)
								.style("font-weight","bold")
								.attr("transform", function(d) {
									return "translate(" + depthpos[source.type][d.depth+1] + "," + -15 + ") rotate(" + (source.type == 'taxa' ? -35 : 35) + ")";
								});
								
							upddepthlabels.select("text")
								.attr("visibility", "visible");
							
							var labelexit = depthlabels.exit().transition()
								.duration(duration)
								.remove();
								
							labelexit.select("text")
								.attr("visibility","hidden");
						}

						// Update the bipartite graph after changes to data_cube
						function updateBPgraph() {
							var bpData = getLinkData();
							var data = {data:bP.partData(bpData, data_cube.displayed_taxa, data_cube.displayed_funcs), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
							var visdata = bP.updateGraph(data, bpG, bpdims, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs, highlightOverall, dehighlightOverall);
							return visdata;
						}

						
						// Toggle children on click.
						function click(d) {
								if (d.values) { //collapse
									if (d.depth > 0) {//don't collapse the root
										collapseTree(d);
										d.type == 'taxa' ? data_cube.collapse_taxon(d.key) : data_cube.collapse_func(d.key);
										bpvisdata = updateBPgraph();
										//console.log(bpvisdata.toSource());
									}
								} else { //expand
									if (d._values[0].hasOwnProperty('key')) {
										d.values = d._values;
										d._values = null;
										d.type == 'taxa' ? data_cube.expand_taxon(d.key) : data_cube.expand_func(d.key);
										bpvisdata = updateBPgraph();
									} else {
									}
									
							   }
							update(d);
							update_otu_bar();
							update_func_bar();
						}

						
						// collapse all children of the collapsing node recursively
						function collapseTree(d) {
							if (d.values) {
								d._values = d.values;
								d.values = null;
								d._values.forEach(collapseTree);
							}
						}
						
						// get the total depth of the tree to the deepest leaf
						function getDepth(rootnode) {
							var depth = 0;
							if (rootnode.values) {
								rootnode.values.forEach(function(d) {
									var tmpDepth = getDepth(d);
									if (tmpDepth > depth) {
										depth = tmpDepth;
									}
								})
							}
							return 1+depth;
						}
						
						
						
						function highlightOverall(taxonName, functionName, highlightwhat) {
							if (highlightwhat == 1) {
								// Highlight tree
								var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
									return d.key == taxonName;
								} );
								var treedatainterestobj = SVGs['taxa'].selectAll("g.node").filter( function(d) {
									return d.key == taxonName;
								})
								highlightTree( treedatainterest[0], treedatainterestobj[0]);
								
								// Highlight BP graph
								m = 0;
								displayed = data_cube.displayed_taxa;
								ind = displayed.indexOf(taxonName);
								//console.log(ind);
								bP.selectSegment(m, ind, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs);

								// Highlight  Taxa Bar Chart
								otu_bar.select_bars(taxonName);

								// Highlight Function Bar Chart
								fB.select_contribution(taxonName);
							}
							
							if (highlightwhat == 2) {
								// Highlight tree
								var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
									return d.key == functionName;
								} );
								var treedatainterestobj = SVGs['func'].selectAll("g.node").filter( function(d) {
									return d.key == functionName;
								})
								highlightTree( treedatainterest[0], treedatainterestobj[0]);
								
								// Highlight BP graph
								m = 1;
								displayed = data_cube.displayed_funcs;
								ind = displayed.indexOf(functionName);
								bP.selectSegment(m, ind, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs);

								// Highlight Function Bar Chart
								fB.select_bars(functionName);
							}
							
							if (highlightwhat == 3) {
								//highlight taxa tree
								var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
									return d.key == taxonName;
								} );
								var treedatainterestobj = SVGs['taxa'].selectAll("g.node").filter( function(d) {
									return d.key == taxonName;
								})
								highlightTree( treedatainterest[0], treedatainterestobj[0]);
								
								//highlight function tree
								var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
									return d.key == functionName;
								} );
								var treedatainterestobj = SVGs['func'].selectAll("g.node").filter( function(d) {
									return d.key == functionName;
								})
								highlightTree( treedatainterest[0], treedatainterestobj[0]);
							
								// Highlight Taxa Bar Chart
								otu_bar.select_bars(taxonName);

								// Highlight Function Bar Chart
								fB.select_single_contribution(taxonName, functionName);
							}
						}

						function dehighlightOverall(taxonName, functionName, highlightwhat) {

							if (highlightwhat == 1) {
								// dehighlight tree
								var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
									return d.key == taxonName;
								} );
								dehighlightTree( treedatainterest[0]);
								
								// dehighlight BP graph
								m = 0;
								displayed = data_cube.displayed_taxa;	
								ind = displayed.indexOf(taxonName);
								bP.deSelectSegment(m, ind);

								// dehighlight Taxon Bar Chart
								otu_bar.deselect_bars(taxonName);

								// dehighligh Function Bar Chart
								fB.deselect_contribution(taxonName);
							}
							
							if (highlightwhat == 2) {
								var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
									return d.key == functionName;
								} );
								dehighlightTree( treedatainterest[0]);
								
								//dehighlight BP graph
								m = 1;
								displayed = data_cube.displayed_funcs;
								ind = displayed.indexOf(functionName);
								bP.deSelectSegment(m, ind);

								// dehighlight Function Bar Chart
								fB.deselect_bars(functionName);
							}
							
							if (highlightwhat == 3) {
								// dehighlight taxa tree
								var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
									return d.key == taxonName;
								} );
								dehighlightTree( treedatainterest[0]);
								
								//dehighlight function tree
								var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
									return d.key == functionName;
								} );
								dehighlightTree( treedatainterest[0]);
								
								// dehighlight Taxa Bar Chart
								otu_bar.deselect_bars(taxonName);

								// dehighlight Function Bar Chart
								fB.deselect_single_contribution(taxonName, functionName);
							
							}
						}

						function highlightTree( data, thisobj) {

							var thisnode = data;
							var thisNparents = [];
							thisNparents.push(thisnode);
							while (thisnode.parent) {
								thisnode = thisnode.parent;
								thisNparents.push(thisnode);
							}
							var node = SVGs[data.type].selectAll("g.node");
							data.thisandparents = node.filter(function (d2) { 
								var good = false;
								thisNparents.forEach( function (d4) {
									if (d2.id == d4.id) {
										good = true;} 
										});
								return good;
							})
							
							data.thisandparents.select("circle")
								.style("stroke-width", "5")
								.style("stroke", "green");
								
							data.thisandparents.append("text")
									.text(function (d5) {
									if (d5.values) {
										return d5.key 
									} else {
										""
									}
									})
									.attr("text-anchor", "middle")
									.attr("dy", function (d5, isz) {
										return "-" + (1* d3.select(thisobj.parentNode).select("circle").attr("r") + 6) +  "";
									})
									.attr("transform", "rotate(" + (data.type == 'taxa' ? -30 : 30) + ")");
									
						}

						function dehighlightTree(data) {
							data.thisandparents.select("circle")
								.style("stroke-width", "1")
								.style("stroke", "steelblue");

							data.thisandparents.selectAll("text").remove(); 
						}



					});
				});
			});
		});
	});
});

function hideheader () {
	window.location = '#navsvg';
}

</script>
</body>