<!DOCTYPE html>
<head>
<meta charset="utf-8">

<title>Burrito Visualization</title>

<script src="shared/jquery.js" type="text/javascript"></script>
<script src="shared/shiny.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" href="CSS/shiny-alt.css"/>
<script src="__assets__/shiny-server.js"></script>

</head>
<style> /*

body{ 
	width:100%;
	margin:100px auto;
	overflow: hidden;
}
svg text{
	font-size:8pt;
}
rect{
	shape-rendering:crispEdges;
}

.brush .extent {
  fill-opacity: .1;
  stroke: #fff;
  shape-rendering: crispEdges;
}
*/
body {
/*	width:100%;
	height:100%; */
	overflow: hidden;
	font-family: "Verdana", Verdana, sans-serif;
    font-size:12px;
}
.node circle {
   cursor: pointer;
   fill: #fff;
   stroke: grey;
   stroke-width: 1.5px;
}
.node text {
   font-size: 11px;
}
path.link {
   fill: none;
   stroke: #ccc;
   stroke-width: 1.5px;
}

/*.svg_pattern {
    display:inline-block;
    width: 30%;
    padding: 10px;
    background-color: "yellow";
    border: 1px solid #ddd;
 }
*/
.error {
	background-color="FF0000";
}
.crosshatch {
  background-image: url("data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4JyBoZWlnaHQ9JzgnPgogIDxyZWN0IHdpZHRoPSc4JyBoZWlnaHQ9JzgnIGZpbGw9JyNmZmYnLz4KICA8cGF0aCBkPSdNMCAwTDggOFpNOCAwTDAgOFonIHN0cm9rZS13aWR0aD0nMC41JyBzdHJva2U9JyNhYWEnLz4KPC9zdmc+Cg==");
  background-repeat: repeat;
}
#csvdata {
   display: none;
}
#taxTree{
	float:left;
}
#bpGraph{
	float:left;
}
#funcTree{
	float:left;
}
#navgraph{
	float:top;
}
#mainplot{
	width:100%;
	height:100%;
	vertical-align:top;
}
#mainsvg {
	position:fixed;
	top:0;
	left:0;
	height:100%;
	width:100%;
	background-color:white;
}
#sidebar {
	z-index:5;
}

.sidebutton {
	stroke:black;
	stroke-width:1;
	opacity:1;
	cursor:default;
}

g.switchb rect {
	fill:white;
}

g.switchb.selectedbutton rect {
	fill:green;
	stroke:#005000;
	stroke-width:4;
}

g.uploadb rect {
	fill: orange;
}

g.uploadb.activebutton:hover rect {
	fill:#ffc000;
}

/*g.uploadb:not(activebutton) {
	pointer-events:none;
}*/

.noselect {
	-webkit-touch-callout: none;
	-webkit-user-select: none;
	-khtml-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	cursor:default;
}

.activebutton:hover text {
	opacity:0.5;
}

.activebutton.switchb:hover rect {
	fill:#d4ffd4;
}

.activebutton:active {
	stroke-width:3;
}

#sidebar_hide:hover {
	opacity:1;
}

#sidebar_hide {
	stroke:none;
}
.nullfilesymb {
	fill:none;
	stroke:black;
	stroke-width:3;
	stroke-linejoin:round;
	
} 

white-space: pre-line;
</style>
<body>
<div style="float:left" id="button_holder"></div>
<div>
<h2>Exploring microbial community taxa and functions</h2>
<h4>Click on nodes of the tree to see more details about a taxon or function. Mouse over any taxon or function to see its relationships and contributions across samples. </h4>
<p>Alex Eng, Will Gagne-Maynard, Colin McNally, Cecilia Noecker</p>
<p> data from <a href="http://www.nature.com/ncomms/2014/140120/ncomms4114/abs/ncomms4114.html?message-global=remove" target="_blank">Theriot et al <i>Nature Communications</i> (2014)</a></p>
<br>
<button id="update_button" type="button" class="btn action-button btn-large btn-primary">Update Graphics</button>
<span class="error" id="upload_message"></span>
</div>
<button type="button" onclick = "hideheader()" style="float:right">Hide Header</button>

<div id="mainplot">



<svg id="patternsvg" height="0" width="0" xmlns="http://www.w3.org/2000/svg" version="1.1">
  <defs>
    <pattern id="crosshatch" patternUnits="userSpaceOnUse" width="4" height="4">
      <image xlink:href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0naHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnIHdpZHRoPSc4JyBoZWlnaHQ9JzgnPgogIDxyZWN0IHdpZHRoPSc4JyBoZWlnaHQ9JzgnIGZpbGw9JyNmZmYnLz4KICA8cGF0aCBkPSdNMCAwTDggOFpNOCAwTDAgOFonIHN0cm9rZS13aWR0aD0nMC41JyBzdHJva2U9JyNhYWEnLz4KPC9zdmc+Cg==" x="0" y="0" width="4" height="4">
      </image>
    </pattern>
	
	<pattern id="rarrowspat" patternUnits="userSpaceOnUse" width="30" height = "20">
	    <rect x="0" y="0" width="30" height="30" fill="white" />
		<path d="M 0 2 L 27 10 L 0 18 z" fill="#D7764A" stroke="#D7764A" stroke-width="4" />
	</pattern>
	<pattern id="larrowspat" patternUnits="userSpaceOnUse" width="30" height = "20">
	    <rect x="0" y="0" width="30" height="30" fill="white" />
		<path d="M 30 2 L 3 10 L 30 18 z" fill="#D7764A" stroke="#D7764A" stroke-width="4" />
	</pattern>
  </defs>
</svg>

</div>

<script src="Javascript/textures.js"></script>
<script src="Javascript/d3.v3.min.js"></script>
<script src="Javascript/data_cube.js"></script>
<script src="Javascript/bp2.js"></script>
<script src="Javascript/FuncBar.js"></script>
<script src="Javascript/otu_stacked_bar.js"></script>
<script src="Javascript/colorbrewer.js"></script>
<script src="Javascript/upload.js"></script>
<script src="Javascript/buttons.js"></script>
<script src="Javascript/input_parsing.js"></script>
<script src="Javascript/mainui.js"></script>

<script>



var aspecrat = window.innerWidth / window.innerHeight;

var width = 1000 * aspecrat;
var height = 1000;
var hidewidth = 30;
var margin ={left:(10 + hidewidth), right:20, top:20, bottom:20 , btwnavbar:40, btwbars:40};
var barDimensions = {width: (width/2 - (margin.btwbars/2) - margin.left), height: (height / 2) - margin.bottom - (margin.btwnavbar/2) };
var navDims = {width: (width - margin.left - margin.right), height: (height/2) - margin.top - (margin.btwbars/2)};
navDims.treewidth = navDims.width * 2/9;
var bpdims = {height:navDims.height, width: navDims.width, header:margin.top};
var i = 0,
duration = 300,
taxaroot,
funcroot,
roots = {};

var TaxaTree = d3.layout.tree()
    .children(function (d) { return d.values; })
    .size([(navDims.height), navDims.treewidth]);

var FuncTree = d3.layout.tree()
    .children(function (d) { return d.values;})
    .size([(navDims.height), navDims.treewidth]);

var trees = [];
trees["taxa"] = TaxaTree;
trees["func"] = FuncTree;

var diagonal = d3.svg.diagonal()
.projection(function (d) {
return [d.y, d.x];
});

var MainSVG = d3.select("#mainplot").append("svg")
.attr("id","mainsvg")
.attr("viewBox","0 0 " + (width - hidewidth) + " " + height + "")
.attr("preserveAspectRatio","none");

var sidebarz = d3.select("#mainsvg").append("svg")
.attr("id","sidebar")
.attr("x",hidewidth)
.attr("y",0)
.attr("width",width)
.attr("height",height)

var sidebar_background = d3.select("#sidebar").append("rect")
.attr("id","sidebar_background")
.attr("x",0)
.attr("y",0)
.attr("width",width)
.attr("height",height)
.attr("fill","#e0e0eb");

button_maker.add_rect_button(d3.select("#mainsvg"), "sidebar_hide", 0, 0, hidewidth, height,"","url(#larrowspat)", "", function() {
//console.log("clicked")
        var curpos = parseFloat(d3.select("#sidebar")[0][0].attributes.x.value);
	if (curpos > -10) {
		sidebarz.transition().attr("x",-1 * width).duration(500);
		MainSVG.select("#sidebar_hide").select("rect").transition().attr("fill","url(#rarrowspat)");
	} else {
		sidebarz.transition().attr("x",hidewidth).duration(500);
		MainSVG.select("#sidebar_hide").select("rect").transition().attr("fill","url(#larrowspat)");
	}
})



mainui.createUI(d3.select("#sidebar"));


draw_everything = function(tax_abund_text, contribution_table, tax_hierarchy_text, func_hierarchy_text, samp_map_text, func_averages){

	console.log("Redrawing")
	
	// Find the new window size, adjust the aspect ratio
	aspecrat = window.innerWidth / window.innerHeight;
	width = 1000 * aspecrat;
	barDimensions = {width: (width/2 - (margin.btwbars/2) - margin.left), height: (height / 2) - margin.bottom - (margin.btwnavbar/2) };
	navDims = {width: (width - margin.left - margin.right), height: (height/2) - margin.top - (margin.btwbars/2)};
	navDims.treewidth = navDims.width * 2/9;
	bpdims = {height:navDims.height, width: navDims.width, header:margin.top};
	TaxaTree.size([(navDims.height), navDims.treewidth]);
	FuncTree.size([(navDims.height), navDims.treewidth]);
	MainSVG.attr("viewBox","0 0 " + width + " " + height + "")
	
	d3.select("#navbar").remove()
	d3.select("#taxa_bars").remove()
	d3.select("#func_bars").remove()

	d3.select("#navbar").remove()
	d3.select("#taxa_bars").remove()
	d3.select("#func_bars").remove()

	var NavSVG = MainSVG.insert("svg", "#sidebar")
    	.attr("x",margin.left)
	.attr("y",margin.top)
	.attr("width", width - margin.left - margin.right)
	.attr("height", (height/2) - margin.top - (margin.btwnavbar / 2))
	.attr("id","navbar");	
	
/*	NavSVG.append("rect")   //rectangle around the navbar, to help figure out positioning
		.attr("x",0)
		.attr("y",0)
		.attr("width",width - margin.left - margin.right)
		.attr("height",(height/2) - margin.top - (margin.btwnavbar / 2))
		.style("fill","none")
		.style("stroke","green") */
		
		
	var bpG = NavSVG.append("g")
		.attr("transform","translate("+ (width / 2) +","+ margin.top +")");
		
	var TaxaTreeG = NavSVG.append("g")
	    .attr("transform", "translate(" + 5 + "," + margin.top + ")");
		

	var FuncTreeG = NavSVG.append("g")
	    .attr("transform", "translate(" + (navDims.width - navDims.treewidth - 5) +  "," + margin.top + ")");



	var TaxaBar = MainSVG.insert("svg", "#sidebar")
		.attr("x",margin.left)
		.attr("y",(height/2) + (margin.btwnavbar/2))
		.attr("width",(width/2) - margin.left - (margin.btwbars/2))
		.attr("height",(height/2) - margin.bottom - (margin.btwnavbar/2))
		//.attr("width",100)
		//.attr("height",100)
		//.attr("viewBox","0 0 100 100")
		.attr("id", "taxa_bars")
		//.attr("preserveAspectRatio","none");
		//.attr("transform","scale(2.0)");


		
		
	var FunctionBar = MainSVG.insert("svg", "#sidebar")
		.attr("x",(width/2) + (margin.btwbars/2))
		.attr("y",(height/2) + (margin.btwnavbar/2))
		.attr("width",(width/2) - margin.right - (margin.btwbars/2))
		.attr("height",(height/2) - margin.bottom - (margin.btwnavbar/2))
		//.attr("viewBox","0 0 100 100")
		.attr("id", "func_bars");
		
		
	var bpvisdata;

	var SVGs = {};
	SVGs["taxa"] = TaxaTreeG;
	SVGs["func"] = FuncTreeG;

	var levelNames = {};
	var curlevelNames = {};
	levelNames['taxa'] = ["Kingdom", "Phylum", "Class", "Order", "Family", "Genus", "Species", "OTU"];
	levelNames['func'] = ["Category", "SuperPathway", "SubPathway"];
	curlevelNames['taxa'] = levelNames['taxa'];
	curlevelNames['func'] = levelNames['func'];

	taxa_tree_data = d3.tsv.parse(tax_hierarchy_text);

	func_tree_data = d3.tsv.parse(func_hierarchy_text);
	func_averages = d3.tsv.parse(func_averages)
//	console.log(func_averages)
	samplemap = d3.tsv.parse(samp_map_text);

	otu_abundance_data_transpose = d3.tsv.parse(tax_abund_text);
	var fix_otus = function(otu_data, samples){
		new_otu_data = []
		for(j=0; j < samples.length; j++){
			new_otu_data[j] = {}
			new_otu_data[j]["Sample"] = samples[j]
			for(k=0; k < otu_data.length; k++){
				new_key = otu_data[k]["OTU_ID"] // Can we key anonymously? Maybe set name of column ourselves so it always matches
				new_otu_data[j][new_key] = +otu_data[k][samples[j]]
			}

		}	
		return new_otu_data;
	}

	//console.log(otu_abundance_data_transpose)

otu_abundance_data = fix_otus(otu_abundance_data_transpose, d3.keys(contribution_table).sort()) //this puts samples in alphabetical order currently

//filter out things in mapping files but not in input data
//console.log(otu_abundance_data)
taxa_tree_data = taxa_tree_data.filter(function(d){
	return d3.keys(otu_abundance_data[0]).indexOf(d.OTU_ID) != -1
	})
	//console.log(taxa_tree_data);
/*
    all_kos = d3.set(func_tree_data.map(function(d){ return d.KO})).values()
    all_kos = all_kos.filter(function(d){
        count = 0
        sample_count = 0
        while(count == 0 & sample_count < (d3.keys(contribution_table)).length){
          for(otu in contribution_table[d3.keys(contribution_table)[sample_count]]){
            if(contribution_table[d3.keys(contribution_table)[sample_count]][otu].hasOwnProperty(d)){
            	if(contribution_table[d3.keys(contribution_table)[sample_count]][otu][d] != 0){
            		count += 1
            	}
            }
          }
          sample_count += 1
        }
        return count > 0
      })
      func_tree_data = func_tree_data.filter(function(d){
        return all_kos.indexOf(d.KO) != -1
      })
      console.log(func_tree_data)
*/	
	//initialize display cube
	var data_cube = data_cube_wrapper.make_cube(); //defines the functions needed
	data_cube.initialize_cube(contribution_table, taxa_tree_data, func_tree_data, func_averages);

	//if( not expand to OTU level
	genus_abundance_data = data_cube.reduce_to_genus(otu_abundance_data)

	var setUpColorScale = function(main_list, list_type, color_scale){ //list_type is taxa or funcs
		//1st - divide up color space into number of leaves
		//then assign each subgroup of leaves alternating extremes
		//then assign each parent extreme or average value of its children
		for(j=0; j < main_list.length; j++){
			if(list_type=="taxa"){
				var leaves = data_cube.get_leaves(main_list[j], data_cube.taxa_lookup)
			} else {
				var leaves = data_cube.get_leaves(main_list[j], data_cube.func_lookup)
			}
		    color_range = leaves.length //number of colors to expand in each direction depends on # of leaves

		    var core_color = d3.hcl(color_scale(main_list[j]))
	    	new_colors = []
	    	flip = -1
	    	for(k=0; k < color_range; k++){
	    		var new_color = d3.hcl()
				new_color["l"] = core_color["l"] - 36*flip*(k + (k%2))/(color_range+1)
	      		new_color["h"] = core_color["h"] - 8*flip*(k+ (k%2))/(color_range+1)
	      		new_color["c"] = core_color["c"] - 4*flip*(k+ (k%2))/(color_range+1)
	      		//console.log(new_color)
	      		new_colors.push(new_color)
	      		flip *= -1

	      	}
			new_colors = new_colors.sort(function(a,b){ return a.l - b.l })

	      	if(list_type=="taxa"){
	      		layer1 = data_cube.taxa_lookup[main_list[j]]
	      		descendents = data_cube.get_descendents(main_list[j], data_cube.taxa_lookup)
	      		first_level = descendents.filter(function(d){ return data_cube.taxa_lookup[d].level == 1})
	      	} else {
	      		layer1 = data_cube.func_lookup[main_list[j]]
	      		descendents = data_cube.get_descendents(main_list[j], data_cube.func_lookup)
	      		first_level = descendents.filter(function(d){ return data_cube.func_lookup[d].level == 1})
	      	}
	      	num_levels = layer1.level

	      	color_count = 0	      	
	      	for(k=0; k < first_level.length; k++){
	      		if(list_type=="taxa"){
	      			desc_leaves = data_cube.get_leaves(first_level[k], data_cube.taxa_lookup)
	      		} else {
	      			desc_leaves = data_cube.get_leaves(first_level[k], data_cube.func_lookup)	      			
	      		}
	      		color_slice = new_colors.slice(color_count, color_count + desc_leaves.length) 
	      		color_count += desc_leaves.length
	      		//assign variants to each group of leaves
	      		for(m=0; m < desc_leaves.length; m++){
	      			if(color_scale.domain().indexOf(desc_leaves[m])==-1){
	      				if(m % 2==0){ //go from front or back
			    			color_scale.range().push(color_slice[m])
	      				} else {
	      					color_scale.range().push(color_slice[desc_leaves.length-m])
	      				}
	      				color_scale(desc_leaves[m])
	      			}
	      		}
	      	}
	      	//now get the rest of the levels, assign mean or most extreme value of descendents
	      	level = 1
	      	while(level < num_levels){
	      		if(list_type=="taxa"){
	      			level_items = descendents.filter(function(d){ return data_cube.taxa_lookup[d].level == level })
	      		} else {
	      			level_items = descendents.filter(function(d){ return data_cube.func_lookup[d].level == level })
	      		}
	      		parent_color = core_color
	      		for(m=0; m < level_items.length; m++){
	      			if(list_type=="taxa"){
	      				desc_leaves = data_cube.get_leaves(level_items[m], data_cube.taxa_lookup)
	      			} else {
	      				desc_leaves = data_cube.get_leaves(level_items[m], data_cube.func_lookup)
	      			}
	      			desc_colors = desc_leaves.map(function(d){ return d3.hcl(color_scale(d)) })
	      		if(m==0 & level_items.length > 1){
	      			parent_color.h = d3.min(desc_colors.map(function(d){ return d.h}))
	      			parent_color.c = d3.min(desc_colors.map(function(d){ return d.c}))
	      			parent_color.l = d3.min(desc_colors.map(function(d){ return d.l}))
	      		} else if(m == level_items.length -1 & m != 0) {
	      			parent_color.h = d3.max(desc_colors.map(function(d){ return d.h}))
	      			parent_color.c = d3.max(desc_colors.map(function(d){ return d.c}))
	      			parent_color.l = d3.max(desc_colors.map(function(d){ return d.l}))
	      		} else{
					parent_color.h = d3.mean(desc_colors.map(function(d){ return d.h}))
	      			parent_color.c = d3.mean(desc_colors.map(function(d){ return d.c}))
	      			parent_color.l = d3.mean(desc_colors.map(function(d){ return d.l}))
	      		
	      		}
		      	if(color_scale.domain().indexOf(level_items[m])==-1){
		      		color_scale.range().push(parent_color.toString())
	      			color_scale(level_items[m])
	      		}
	      		}
	      		level++;
	      	}
	      }
		return color_scale;
	}

	//set up colors using data cube
	//colors	
	//start one level in for bacteria but at the 0th level for functions
	num_function_categories = data_cube.func_tree.length
	num_taxa_categories = 0
	for(j=0; j < data_cube.taxa_tree.length; j++){
		num_taxa_categories += data_cube.taxa_tree[j].values.length
	}

	//taxa colors
	if(num_taxa_categories > d3.keys(colorbrewer["Set3"]).pop()+d3.keys(colorbrewer["Dark2"]).pop()){
		console.log("too many taxa categories, colors will repeat")
	}
	if(num_taxa_categories <= d3.keys(colorbrewer["Set3"]).pop()){
		taxa_palette = colorbrewer["Set3"][num_taxa_categories]
		//taxa_palette = taxa_palette.reverse()
	} else {
		taxa_palette = colorbrewer["Set3"][(d3.keys(colorbrewer["Set3"]).pop()-1)].concat(colorbrewer["Dark2"][num_taxa_categories -  d3.keys(colorbrewer["Set3"]).pop()])
	}
	if(num_function_categories > d3.keys(colorbrewer["Set1"]).pop()+d3.keys(colorbrewer["Dark2"]).pop()){
		console.log("too many function categories, colors will repeat")
	}

	if(num_function_categories <= d3.keys(colorbrewer["Set1"]).pop()){
		func_palette = colorbrewer["Set1"][num_function_categories]
		} else {
			func_palette = colorbrewer["Set1"][(d3.keys(colorbrewer["Set1"]).pop()-1)].concat(colorbrewer["Dark2"][num_function_categories - d3.keys(colorbrewer["Set1"]).pop()])
		}

	var taxa_colors = d3.scale.ordinal()
	taxa_colors.range(taxa_palette)
	main_taxa = []
	for(j=0; j < data_cube.taxa_tree.length; j++){
		main_taxa = main_taxa.concat(data_cube.taxa_tree[j].values.map(function(d){ return d.key;}))
	}
	//console.log(main_taxa)
	taxa_colors.domain(main_taxa)
	taxa_colors = setUpColorScale(main_taxa, "taxa", taxa_colors)

/*	taxa_colors.range().push("black")
	console.log(taxa_colors("Bacteria"))
*/
	kingdoms = data_cube.taxa_tree.map(function(d){ return d.key})
	col1 = d3.hsl("black")
	//console.log(col1)
	//if there are other kingdoms besides Bacteria, shades of grey
	for(j=0; j < kingdoms.length; j++){
		taxa_colors.range().push(col1)
		taxa_colors(kingdoms[j])
		col1["l"] +=  (j+1)/(kingdoms.length + 1)
	}
	taxa_colors.range().push("black")
	taxa_colors("All Taxa")


	//func colors
	var func_colors = d3.scale.ordinal()
	func_colors.range(func_palette)
	main_funcs = data_cube.func_tree.map(function(d){ return d.key;})
	func_colors.domain(main_funcs)
	func_colors = setUpColorScale(main_funcs, "funcs", func_colors)
	func_colors.range().push("black")
	func_colors("All Functions")


	//sample colors
	groupValsAll = samplemap.map(function(d,i){ 
		return d["Group"]; })

	groupVals = groupValsAll.filter(function(d,i){ return groupValsAll.indexOf(d)===i; })

	var sampleColor = d3.scale.ordinal().domain(groupVals).range(colorbrewer["Paired"][Math.max(4,groupVals.length)].slice(0,groupVals.length));
	
	getLinkData = function(){
		//get unique linked functions for each taxon
		allSamples = d3.keys(data_cube.displayed_contribution_cube);
		var all_taxa_links = []; //{Taxa:[], Functions:[]};
		data_cube.displayed_taxa.map(function(t,i){
			data_cube.displayed_funcs.map(function(f,i){
				var foo = allSamples.map(function(d){
					return data_cube.get_contribution(d,t,f);
				})
				if(d3.sum(foo)!==0){
					all_taxa_links.push({Taxa:t, Functions:f, numKO:1});
				}
			})
		});
		return all_taxa_links;
	}

	//this gets the data for the functional bar chart

	getFuncBarData = function(){
		var contributions = [];
		var samples = [];
		var funcs = [];
		var taxa = [];

		var all_func_data = [];
		var count = 0;
		var tcount = 0;

		allSamples = d3.keys(data_cube.displayed_contribution_cube).sort();
		var all_taxa_links = []; //{Taxa:[], Functions:[]};
		//loop through all the functions
		//this keeps all functions together

		//loop through Samples, funcs and taxa and create arrays of the data
		allSamples.map(function(d){	
			samples.push({sample:d});
		});
		var my_displayed_funcs = data_cube.displayed_funcs.slice(0);
		my_displayed_funcs.reverse();
		(my_displayed_funcs).map(function(z){
			funcs.push(z);
		});
		var my_displayed_taxa = data_cube.displayed_taxa.slice(0);
		my_displayed_taxa.reverse();
		(my_displayed_taxa).map(function(t,i){
			taxa.push(t)
		});
		//then loop through sequentially to populate an array of all the samples
		samples.map(function(n){
			funcs.map(function(m){

				taxa.map(function(tt){	
					contributions.push({func:m, Taxa:tt, Sample:n.sample, contributions:data_cube.get_contribution([n.sample],[tt],[m])});})
			})
		var temp = [];
		contributions.map(function(q){
			if (q.Sample == n.sample) {
				temp.push({func:q.func, Taxa:q.Taxa, Sample:q.Sample, contributions:q.contributions});}
		})

		all_func_data.push({data:temp, Sample:n.sample});
		count = count + 1
		});
		return all_func_data;
	}

	function sort_nest(x, y){
		if (x.key < y.key){
			return -1;
		} else if (x.key > y.key){
			return 1;
		} else {
			return 0;
		}
	}

	//console.log(data_cube.displayed_contribution_cube[d3.keys(data_cube.displayed_contribution_cube)[0]].toSource());
	var taxLevels = d3.keys(taxa_tree_data[0]);
	//data_cube.expand_taxon("Bacteria");

	var bpData = getLinkData();
	var data = {data:bP.partData(bpData, data_cube.displayed_taxa, data_cube.displayed_funcs), id:'Genomes', header:["Taxa","Functions", "Genomes"]};


	//draw the stacked bar

	var stackData = getFuncBarData();

	fB.Draw(stackData, samplemap, func_colors, FunctionBar, barDimensions, highlightOverall, dehighlightOverall, sampleColor);


	var otu_bar_data = otu_bar.make_data(genus_abundance_data, data_cube);

	otu_bar.draw(otu_bar_data, samplemap, taxa_colors, TaxaBar, barDimensions, highlightOverall, dehighlightOverall, sampleColor);


	bP.draw(data, bpG, bpdims, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs,highlightOverall, dehighlightOverall);


	function update_otu_bar(){
		//remove old graph before redrawing new
		TaxaBar.selectAll("g").remove();
		otu_bar_data = otu_bar.make_data(genus_abundance_data, data_cube);
		otu_bar.draw(otu_bar_data, samplemap, taxa_colors, TaxaBar, barDimensions, highlightOverall, dehighlightOverall, sampleColor);
	}

	function update_func_bar(){
		//remove old graph before redrawing new
			FunctionBar.selectAll("g").remove();
			var func_data = getFuncBarData();
			fB.Draw(func_data, samplemap, func_colors, FunctionBar, barDimensions, highlightOverall, dehighlightOverall, sampleColor);

	}

	//data_cube.expand_func("Metabolism");
	var bpData = getLinkData();
	var data = {data:bP.partData(bpData, data_cube.displayed_taxa, data_cube.displayed_funcs), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
	bpvisdata = bP.updateGraph(data, bpG, bpdims, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs, highlightOverall, dehighlightOverall);

	var taxa_data = d3.nest()
        .key(function(d) { return d.Kingdom; })
        .key(function(d) { return d.Phylum; })
        .key(function(d) { return d.Class; })
        .key(function(d) { return d.Order; })
        .key(function(d) { return d.Family; })
        .key(function(d) { return d.Genus; })
        .key(function(d) { return d.Species; })
        .key(function(d) { return d.OTU_ID; })
        .entries(taxa_tree_data);    

    var curr_taxa = [];
    for (var i = 0; i < taxa_data.length; i++){
	    curr_taxa.push(taxa_data[i]);
	}

    for (; curr_taxa.length > 0;){
    	curr_taxon = curr_taxa.shift();
    	if (!data_cube.is_leaf(curr_taxon)){
    		curr_taxon.values.sort(sort_nest);
    		for (var i = 0; i < curr_taxon.values.length; i++){
    			curr_taxa.push(curr_taxon.values[i]);
    		}
    	}
    }

    newTaxaData = {
        "key": "All Taxa",
        "values": taxa_data,
    }

    taxaroot = newTaxaData;
    taxaroot.x0 = height/4;
    taxaroot.y0 = 0;
	
    function collapse(d) {
		d.type = settype;
            if (d.values) {
                d._values = d.values;
                d._values.forEach(collapse);
                d.values = null;
            }
        
    }
	
	var settype = 'taxa';
    taxaroot.values.forEach(collapse);
	taxaroot.type = 'taxa';

	function countchildren(rootnode) {
		var totchildren = 0;
		var addone = 1;
		if (rootnode.values) {
			rootnode.values.forEach( function(d) {
				totchildren = totchildren + countchildren(d);
			})
			addone = 0;
		} 
		if (rootnode._values) {
			rootnode._values.forEach( function(d) {
				totchildren = totchildren + countchildren(d);
			})
			addone = 0;
		}
		rootnode.Ndescendents = totchildren;
		return (totchildren + addone);
	}
	
	//get mean taxon abundances across samples
	var taxa_means = {}

	function get_taxa_sample_means(otu_abundance_data, data_cube){
		otus = d3.keys(otu_abundance_data[0]).filter(function(d){ return d != "Sample"})
		for(j = 0; j < otus.length; j++){
			taxa_means[otus[j]] = 0
			for(k = 0; k < otu_abundance_data.length; k++){
				taxa_means[otus[j]] += otu_abundance_data[k][otus[j]]*1
			}
			taxa_means[otus[j]] = taxa_means[otus[j]]/(otu_abundance_data.length)
		}
	}

	function getAvgs(rootnode){
    	if(rootnode.type=="func"){
    		//console.log(rootnode)
    		if(rootnode.key != "All Functions"){
    			func_leaves = data_cube.get_leaves(rootnode.key, data_cube.func_lookup)
				rootnode.sampleAvg = data_cube.funcMeans[rootnode.key]
// 				for(j = 0; j < func_leaves.length; j++){
// 					funcAvg += data_cube.funcMeans[func_leaves[j]]
// 				}
//				rootnode.sampleAvg = funcAvg
	    	} else {
	    		rootnode.values.forEach(function(d){
					getAvgs(d)
				})
	    		rootnode.sampleAvg = 0.1
	    	}
		} else {
			//taxa Avgs
			if(rootnode.key != "All Taxa"){
    			taxa_leaves = data_cube.get_leaves(rootnode.key, data_cube.taxa_lookup)
				taxaAvg = 0
				for(j = 0; j < taxa_leaves.length; j++){
					taxaAvg += taxa_means[taxa_leaves[j]]
				}
				rootnode.sampleAvg = taxaAvg
			} else {
				rootnode.values.forEach(function(d){
					getAvgs(d)
				})
				rootnode.sampleAvg = 0.1
			}
		}
		if(rootnode._values){
			rootnode._values.forEach(function(d){
				if(d._values){ getAvgs(d)}
				
			})
		}
	}
	roots["taxa"] = taxaroot;
	countchildren(roots["taxa"]);
	//get means for all OTUs, then for all the way up the tree
	get_taxa_sample_means(genus_abundance_data, data_cube)
	getAvgs(roots["taxa"])
    update(roots["taxa"]);

    //d3.select(self.frameElement).style("height", "800px");


    var function_data = d3.nest()
        .key(function(d) { return d.Category; })
        .key(function(d) { return d.SuperPathway; })
        .key(function(d) { return d.SubPathway; })
        .entries(func_tree_data);  

    //var function_data2 = data_cube.func_tree

	//console.log(function_data)
	//console.log(function_data2)

    var curr_funcs = [];
    for (var i = 0; i < function_data.length; i++){
	    curr_funcs.push(function_data[i]);
	}
    for (; curr_funcs.length > 0;){
    	curr_func = curr_funcs.shift();
    	if (!data_cube.is_leaf(curr_func)){
    		curr_func.values.sort(sort_nest);
    		for (var i = 0; i < curr_func.values.length; i++){
    			curr_funcs.push(curr_func.values[i]);
    		}
    	}
    }  

    newFunctionData = {
        "key": "All Functions",
        "values": function_data,
    }

    funcroot = newFunctionData;
    funcroot.x0 = height/4;
    funcroot.y0 = 0;
	
	settype = 'func';
    funcroot.values.forEach(collapse);
	funcroot.type = settype;
	
	roots["func"] = funcroot;
	countchildren(roots["func"]);
	getAvgs(roots["func"])
    update(roots['func']);

	click(roots['taxa'].values[0])

							
	// Update the tree graphs
	// Expands or collapses the source node, depending on whether it is currently open or closed
	function update(source) {
		// Compute the new tree layout.
		var nodes = trees[source.type].nodes(roots[source.type]).reverse(),
			links = trees[source.type].links(nodes);
			

		var nleaf = 0;
		nodes.forEach(function (d) {
			nleaf = nleaf + (d.values ? 0 : 1);
		})
		/*
		//console.log(nleaf);
		
		var leafC = 1;
		*/
		nodes.forEach(function (d) {
			if (!(d.values)) { 
				var dattype = d.type == "taxa" ? 0 : 1;
				var thedat = -1;

				for (var idxz = 0; idxz < bpvisdata.keys[dattype].length ; idxz++) {
					if (d.key == bpvisdata.keys[dattype][idxz])
						thedat = idxz;
				}
				
				if (thedat >= 0) {
					d.x = bpvisdata.mainBars[dattype][thedat].y;	
				} else { d.x = 0; 
				}
				
				//d.x = (nleaf - leafC)/nleaf * height;
				//leafC = leafC + 1;
			} else { 
				var sumpos = 0;
				d.values.forEach(function (dc) {
					sumpos = sumpos + dc.x;
				})
				d.x = sumpos / d.values.length; 
			}
		})
		
		
		// Normalize for fixed-depth.
		var maxDepth = getDepth(roots[source.type]);
		
		var depthpos = {};
		depthpos['taxa'] = [];
		depthpos['func'] = [];
		nodes.forEach(function (d) {
			if (source.type == 'taxa') {
				//d.y = (d.depth / maxDepth) * treewidth ;
				if (d.depth == maxDepth) {
					//d.y = treewidth;
				}
				depthpos['taxa'][d.depth] = d.y;

			} else {
				//d.y = treewidth - (d.depth / maxDepth) * treewidth;
				d.y = (navDims.treewidth) - d.y;
				depthpos['func'][d.depth] = d.y;
			}
		}); 

		// figure out which depth levels exist
		curlevelNames[source.type] = [];
		for (idxz = 0; idxz < (maxDepth - 1); idxz++) {
			curlevelNames[source.type].push({name: levelNames[source.type][idxz], depth: idxz});
		}
		
		// Update the tree depth labels
		var depthlabels = SVGs[source.type].selectAll("g.depthlabel")
			.data(curlevelNames[source.type])
			
		var newdepthlabels = depthlabels.enter().append("g")
			.attr("class","depthlabel")
			.attr("transform", function(d) {
				return "translate(" + depthpos[source.type][d.depth+1] + "," + -15 + ") rotate(" + (source.type == 'taxa' ? -35 : 35) + ")" ;
			});
			
		newdepthlabels.append("text")
			.text(function (d) {
				return d.name;
				})
			.style("font-weight","bold")
			.attr("text-anchor","middle")
			.attr("visibility", "hidden");
			
		var upddepthlabels = depthlabels.transition()
			.duration(duration)
			.style("font-weight","bold")
			.attr("transform", function(d) {
				return "translate(" + depthpos[source.type][d.depth+1] + "," + -15 + ") rotate(" + (source.type == 'taxa' ? -35 : 35) + ")";
			});
			
		upddepthlabels.select("text")
			.attr("visibility", "visible");
		
		var labelexit = depthlabels.exit().transition()
			.duration(duration)
			.remove();
			
		labelexit.select("text")
			.attr("visibility","hidden");
			
		
			
		
		// Update the nodes…
		var node = SVGs[source.type].selectAll("g.node")
			.data(nodes, function (d) {
			return d.id || (d.id = ++i);
		});

		// Enter any new nodes at the parent's previous position.
		var nodeEnter = node.enter().append("g")
			.attr("class", "node")
			.attr("transform", function (d) {
				return "translate(" + source.y0 + "," + source.x0 + ")";
			})
			.on("click", click)
			.on("mouseover", function (d) {
				if (~d.values) {
					if (d.type == 'taxa') {
						highlightOverall(d.key, "", 1);
					} else {
						highlightOverall("", d.key, 2);
					}
				} else {
					highlightTree(d, this);
				}
												

			})
			.on("mouseout", function(d) {
				if (~d.values) {
					if (d.type == 'taxa') {
						dehighlightOverall(d.key, "", 1);
					} else {
						dehighlightOverall("", d.key, 2);
					}
				} else {
					dehighlightTree(d, this);
				}
				});

		nodeEnter.filter( function(d) { return (~d.values) }).append("rect")
			.attr("x", function (d) {
				if (source.type == 'taxa') {
					return 0; 
				} else {
					return (-170 - d.y);
				}})
			.attr("width", function(d) {
				if (source.type == 'taxa') {
					return "" + (navDims.treewidth + margin.left - d.y) + ""
				} else {
					return 170+d.y;
				}})
			.attr("height", function(d) {
				return (height / 2 / nleaf / 1.5);
				})
			.attr("y", function (d) {
				return (-1 * height / 2 / nleaf / 3); })
			.attr("style","opacity:0")
			;
		
		nodeEnter.append("circle")
			.attr("r", 1e-6)
			.style("fill", function (d) { 
				if(source.type==="taxa"){
					return taxa_colors(d.key); } else {
				 	return func_colors(d.key);
				 } });

/*								return d._values ? "lightsteelblue" : "#fff";
		});
*/							
		node.filter( function (d) {
			return (~d.values) })
				.filter( function(d) { return d3.select(this).select("rect").empty(); })
				.append("rect");

		/*
		nodeEnter.append("text")
			.attr("x", function (d) {
			return source.type == 'taxa' ? 10 : -10;
		})
			.attr("dy", ".35em")
			.attr("text-anchor", function (d) {
			return source.type == 'taxa' ? "start" : "end";
		})
			.text(function (d) {
			   if(d.key != null)
				   return d.key;
		})
			.style("fill-opacity", 1e-6);
		*/
		
		// Transition nodes to their new position.
		var nodeUpdate = node.transition()
			.duration(duration)
			.attr("transform", function (d) {
			return "translate(" + d.y + "," + d.x + ")";
		}); 

		nodeUpdate.filter( function (d) {return (d.values) } ).selectAll("rect").remove();
		
		
				
		nodeUpdate.selectAll("rect")
			.attr("x", function (d) {
				if (source.type == 'taxa') {
					return 0; 
				} else {
					return (-170 - d.y);
				}})
			.attr("width", function(d) {
				if (source.type == 'taxa') {
					return "" + (navDims.treewidth + margin.left - d.y) + ""
				} else {
					return 170+d.y;
				}})
			.attr("height", function(d) {
				return (height / 2 / nleaf / 1.5);
				})
			.attr("y", function (d) {
				return (-1 * height / nleaf / 3); })
			.attr("style","opacity:0")
			;
		
		
		nodeUpdate.select("circle")
			.attr("r", function (d) {
				if(d.sampleAvg && d._values){
					return 25 * Math.sqrt(d.sampleAvg)
					//return (4 * Math.sqrt(d.Ndescendents))
				}else{
					return 4;
				}
			})
			.style("fill", function (d) { 
				if(source.type==="taxa"){
					return taxa_colors(d.key); } else {
				 	return func_colors(d.key);
				 } });

/*								.style("fill", function (d) {
				if (d.values) {
				return "#fff";
				} else {  // has d._values
					if (d._values[0].hasOwnProperty("key")) {
						return "lightsteelblue";
					} else {
						return "#000"
					}
				}
			});
*/
		/*
		nodeUpdate.select("text")
			.style("fill-opacity", function(d) {
				return d.values ? 0 : 1;
			})
			.text(function (d) {
				if( d.values) {
					return "";
				} else {
					if(d.key != null)
				   return d.key;
				}
			}); */
			
			

		// Transition exiting nodes to the parent's new position.
		var nodeExit = node.exit().transition()
			.duration(duration)
			.attr("transform", function (d) {
			return "translate(" + source.y + "," + source.x + ")";
		})
			.remove();

		nodeExit.select("circle")
			.attr("r", 1e-6);

	/*	nodeExit.select("text")
			.style("fill-opacity", 1e-6); */

		
		// Update the links…
		var link = SVGs[source.type].selectAll("path.link")
			.data(links, function (d) {
			return d.target.id;
		});

		// Enter any new links at the parent's previous position.
		link.enter().insert("path", "g")
			.attr("class", "link")
			.attr("d", function (d) {
			var o = {
				x: source.x0,
				y: source.y0
			};
			return diagonal({
				source: o,
				target: o
			});
		});

		// Transition links to their new position.
		link.transition()
			.duration(duration)
			.attr("d", diagonal);

		// Transition exiting nodes to the parent's new position.
		link.exit().transition()
			.duration(duration)
			.attr("d", function (d) {
			var o = {
				x: source.x,
				y: source.y
			};
			return diagonal({
				source: o,
				target: o
			});
		}).remove();

		// Stash the old positions for transition.
		nodes.forEach(function (d) {
			//console.log(d.x);
			//console.log(d.y);
			d.x0 = d.x;
			d.y0 = d.y;
		});
		
/////////////////////// Do depth labels /////////////////////////////
		// figure out which depth levels exist
		curlevelNames[source.type] = [];
		for (idxz = 0; idxz < (maxDepth - 1); idxz++) {
			curlevelNames[source.type].push({name: levelNames[source.type][idxz], depth: idxz});
		}
		//console.log(curlevelNames[source.type][source.type]);
		
		// Update the tree depth labels
		var depthlabels = SVGs[source.type].selectAll("g.depthlabel")
			.data(curlevelNames[source.type])
			
		var newdepthlabels = depthlabels.enter().append("g")
			.attr("class","depthlabel")
			.attr("transform", function(d) {
				return "translate(" + depthpos[source.type][d.depth+1] + "," + 0 + ") rotate(" + (source.type == 'taxa' ? -15 : 15) + ")" ;
			});
			
		newdepthlabels.append("text")
			.text(function (d) {
				return d.name;
				})
			.style("font-weight","bold")
			.attr("text-anchor","middle")
			.attr("visibility", "hidden");
			
		var upddepthlabels = depthlabels.transition()
			.duration(duration)
			.style("font-weight","bold")
			.attr("transform", function(d) {
				return "translate(" + depthpos[source.type][d.depth+1] + "," + 0 + ") rotate(" + (source.type == 'taxa' ? -15 : 15) + ")";
			});
			
		upddepthlabels.select("text")
			.attr("visibility", "visible");
		
		var labelexit = depthlabels.exit().transition()
			.duration(duration)
			.remove();
			
		labelexit.select("text")
			.attr("visibility","hidden");
	}

	// Update the bipartite graph after changes to data_cube
	function updateBPgraph() {
		var bpData = getLinkData();
		var data = {data:bP.partData(bpData, data_cube.displayed_taxa, data_cube.displayed_funcs), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
		var visdata = bP.updateGraph(data, bpG, bpdims, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs, highlightOverall, dehighlightOverall);
		return visdata;
	}

	
	// Toggle children on click.
	function click(d) {
			if (d.values) { //collapse
				if (d.depth > 0) {//don't collapse the root
					collapseTree(d);
					d.type == 'taxa' ? data_cube.collapse_taxon(d.key) : data_cube.collapse_func(d.key);
					bpvisdata = updateBPgraph();
					//console.log(bpvisdata.toSource());
				}
			} else { //expand
				if (d._values[0].hasOwnProperty('key')) {
					d.values = d._values;
					d._values = null;
					d.type == 'taxa' ? data_cube.expand_taxon(d.key) : data_cube.expand_func(d.key);
					bpvisdata = updateBPgraph();
				} else {
				}
				
		   }
		update(d);
		update_otu_bar();
		update_func_bar();
	}

	
	// collapse all children of the collapsing node recursively
	function collapseTree(d) {
		if (d.values) {
			d._values = d.values;
			d.values = null;
			d._values.forEach(collapseTree);
		}
	}
	
	// get the total depth of the tree to the deepest leaf
	function getDepth(rootnode) {
		var depth = 0;
		if (rootnode.values) {
			rootnode.values.forEach(function(d) {
				var tmpDepth = getDepth(d);
				if (tmpDepth > depth) {
					depth = tmpDepth;
				}
			})
		}
		return 1+depth;
	}
	
	
	
	function highlightOverall(taxonName, functionName, highlightwhat) {
		if (highlightwhat == 1) {
			// Highlight tree
			var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
				return d.key == taxonName;
			} );
			var treedatainterestobj = SVGs['taxa'].selectAll("g.node").filter( function(d) {
				return d.key == taxonName;
			})
			highlightTree( treedatainterest[0], treedatainterestobj[0]);
			
			// Highlight BP graph
			m = 0;
			displayed = data_cube.displayed_taxa;
			ind = displayed.indexOf(taxonName);
			//console.log(ind);
			bP.selectSegment(m, ind, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs);

			// Highlight  Taxa Bar Chart
			otu_bar.select_bars(taxonName);

			// Highlight Function Bar Chart
			//console.log(func_colors);
			fB.select_contribution(taxonName, func_colors);
		}
		
		if (highlightwhat == 2) {
			// Highlight tree
			var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
				return d.key == functionName;
			} );
			var treedatainterestobj = SVGs['func'].selectAll("g.node").filter( function(d) {
				return d.key == functionName;
			})
			highlightTree( treedatainterest[0], treedatainterestobj[0]);
			
			// Highlight BP graph
			m = 1;
			displayed = data_cube.displayed_funcs;
			ind = displayed.indexOf(functionName);
			bP.selectSegment(m, ind, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs);

			// Highlight Function Bar Chart
			fB.select_bars(functionName, func_colors);
		}
		
		if (highlightwhat == 3) {
			//highlight taxa tree
			var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
				return d.key == taxonName;
			} );
			var treedatainterestobj = SVGs['taxa'].selectAll("g.node").filter( function(d) {
				return d.key == taxonName;
			})
			highlightTree( treedatainterest[0], treedatainterestobj[0]);
			
			//highlight function tree
			var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
				return d.key == functionName;
			} );
			var treedatainterestobj = SVGs['func'].selectAll("g.node").filter( function(d) {
				return d.key == functionName;
			})
			highlightTree( treedatainterest[0], treedatainterestobj[0]);
		
			// Highlight Taxa Bar Chart
			otu_bar.select_bars(taxonName);

			// Highlight Function Bar Chart
			fB.select_single_contribution(taxonName, functionName, func_colors);
		}
	}

	function dehighlightOverall(taxonName, functionName, highlightwhat) {

		if (highlightwhat == 1) {
			// dehighlight tree
			var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
				return d.key == taxonName;
			} );
			dehighlightTree( treedatainterest[0]);
			
			// dehighlight BP graph
			m = 0;
			displayed = data_cube.displayed_taxa;	
			ind = displayed.indexOf(taxonName);
			bP.deSelectSegment(m, ind, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs);

			// dehighlight Taxon Bar Chart
			otu_bar.deselect_bars(taxonName, taxa_colors);

			// dehighligh Function Bar Chart
			fB.deselect_contribution(taxonName, func_colors);
		}
		
		if (highlightwhat == 2) {
			var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
				return d.key == functionName;
			} );
			dehighlightTree( treedatainterest[0]);
			
			//dehighlight BP graph
			m = 1;
			displayed = data_cube.displayed_funcs;
			ind = displayed.indexOf(functionName);
			bP.deSelectSegment(m, ind, taxa_colors, func_colors, data_cube.displayed_taxa, data_cube.displayed_funcs);

			// dehighlight Function Bar Chart
			fB.deselect_bars(functionName, func_colors);
		}
		
		if (highlightwhat == 3) {
			// dehighlight taxa tree
			var treedatainterest = trees['taxa'].nodes(roots['taxa']).filter( function(d) {
				return d.key == taxonName;
			} );
			dehighlightTree( treedatainterest[0]);
			
			//dehighlight function tree
			var treedatainterest = trees['func'].nodes(roots['func']).filter( function(d) {
				return d.key == functionName;
			} );
			dehighlightTree( treedatainterest[0]);
			
			// dehighlight Taxa Bar Chart
			otu_bar.deselect_bars(taxonName, taxa_colors);

			// dehighlight Function Bar Chart
			fB.deselect_single_contribution(taxonName, functionName, func_colors);
		
		}
	}

	function highlightTree( data, thisobj) {

		var thisnode = data;
		var thisNparents = [];
		thisNparents.push(thisnode);
		while (thisnode.parent) {
			thisnode = thisnode.parent;
			thisNparents.push(thisnode);
		}
		var node = SVGs[data.type].selectAll("g.node");
		data.thisandparents = node.filter(function (d2) { 
			var good = false;
			thisNparents.forEach( function (d4) {
				if (d2.id == d4.id) {
					good = true;} 
					});
			return good;
		})
		
		data.thisandparents.select("circle")
			.style("stroke-width", "5")
			.style("stroke", "black");
			
		data.thisandparents.append("text")
				.text(function (d5) {
				if (d5.values) {
					name_split = (d5.key.split('_')).pop()
					return name_split;
					//return d5.key 
				} else {
					""
				}
				})
				.attr("text-anchor", "middle")
				.attr("dy", function (d5, isz) {
					return "-" + (1* d3.select(thisobj.parentNode).select("circle").attr("r") + 6) +  "";
				})
				.attr("transform", "rotate(" + (data.type == 'taxa' ? -30 : 30) + ")");
				
	}

	function dehighlightTree(data) {
		data.thisandparents.select("circle")
			.style("stroke-width", "1")
			.style("stroke", "grey");

		data.thisandparents.selectAll("text").remove(); 
	}
}

var uploader = uploader_wrapper.make_uploader(draw_everything);

mainui.uploadMode = "Function"; // Should not have to do this, try to eliminate later

uploader.load_default_data();

//Shiny.addCustomMessageHandler("picrust_status", function(message){console.log(message)})
	
</script>
</body>
