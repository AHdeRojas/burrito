<!DOCTYPE html>
<meta charset="utf-8">
<style>
body{
	width:1200px;
	margin:100px auto;
}
svg text{
	font-size:10px;
}
rect{
	shape-rendering:crispEdges;
}
</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="data_cube.js"></script>
<script src="bp2.js"></script>
<script src="FuncBar.js"></script>
<script>



var width = 400, height = 610, margin ={b:10, top:40, l:80, left:30, right:30, bottom:10};

var i = 0,
    duration = 300,
    taxaroot,
	funcroot,
	roots = {};

var TaxaTree = d3.layout.tree()
    .children(function (d) { return d.values; })
    .size([height, width/2]);

var FuncTree = d3.layout.tree()
    .children(function (d) { return d.values;})
    .size([height, width/2]);

var FuncBar = d3.layout.tree()
    .children(function (d) { return d.values;})
    .size([height, width/2]);

var trees = [];
trees["taxa"] = TaxaTree;
trees["func"] = FuncTree;

var diagonal = d3.svg.diagonal()
    .projection(function (d) {
    return [d.y, d.x];
});

var TaxaTreeSVG = d3.selectAll("#taxTree").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var FuncTreeSVG = d3.select("#funcTree").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

var FuncBarChartSVG = d3.select("#funcBar").append("svg")
    .attr("width", width + margin.right + margin.left)
    .attr("height", height + margin.top + margin.bottom)
    .append("g")
    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");


var bpvisdata;

var SVGs = {};
SVGs["taxa"] = TaxaTreeSVG;
SVGs["func"] = FuncTreeSVG;
SVGs["funcBar"] = FuncBarChartSVG;

  d3.tsv("reduced_genus_pathway_metagenome_contributions.txt", function(error, contribution_data) {
    d3.tsv("taxa_mapping.txt", function(error, taxa_tree_data){
      d3.tsv("functional_mapping.txt", function(error, func_tree_data){
        d3.tsv("reduced_pathway_functions_transpose.txt", function(error, func_rel_abundance_data){
			d3.tsv("reduced_genus_pathway_links.txt", function(error, linkData){
				//initialize display cube
				var data_cube = data_cube_wrapper.make_cube();
				data_cube.initialize_cube(contribution_data, taxa_tree_data, func_tree_data, func_rel_abundance_data);

				//data_cube.expand_taxon('Bacteria');
				data_cube.expand_func("Metabolism");


				//data_cube.collapse_taxon("Bacteria");
				//data_cube.collapse_func("Cellular Processes");



				getLinkData = function(){
					//get unique linked functions for each taxon
					allSamples = d3.keys(data_cube.displayed_contribution_cube);
					var all_taxa_links = []; //{Taxa:[], Functions:[]};
					allSamples.map(function(d){
						(data_cube.displayed_taxa).map(function(t,i){
							if(all_taxa_links.map(function(d){return d.Taxa;}).indexOf(t)===-1){
							if((data_cube.displayed_contribution_cube[d]).hasOwnProperty(t)){
								for(j=0; j<d3.keys(data_cube.displayed_contribution_cube[d][t]).length; j++){
									all_taxa_links.push({Taxa:t, Functions:d3.keys(data_cube.displayed_contribution_cube[d][t])[j],
										numKO:1});
								}
									//all_taxa_links.Functions.push(d3.keys(data_cube.displayed_contribution_cube[d][t])[j]);
							}
							}
						});
					});
					return all_taxa_links;
					//a.filter(function(item, i, ar){ return ar.indexOf(item) === i; });
				}

				//stacked bar 
				//use map function to loop through




				getFuncBarData = function(){
					//get unique functions for each taxon
					var contributions = [];
					var samples = [];
					var funcs = [];
					var taxa = [];

					var all_func_data = [];
					var count = 0;
					var tcount = 0;

					allSamples = d3.keys(data_cube.displayed_contribution_cube);
					var all_taxa_links = []; //{Taxa:[], Functions:[]};
					//loop through all the functions
					//this keeps all functions together

					//loop through Samples, funcs and taxa and create arrays of the data
					allSamples.map(function(d){	
						samples.push({sample:d});
					});
					(data_cube.displayed_funcs).map(function(z){
						funcs.push(z);
					});
					(data_cube.displayed_taxa).map(function(t,i){
						taxa.push(t)
					});
					//then loop through sequentially to populate an array of all the samples
					samples.map(function(n){
						funcs.map(function(m){

							taxa.map(function(tt){	
								contributions.push({func:m, Taxa:tt, Sample:n.sample, contributions:data_cube.get_contribution([n.sample],[tt],[m])});})
						})
					var temp = [];
					contributions.map(function(q){
						if (q.Sample == n.sample) {
							temp.push({func:q.func, Taxa:q.Taxa, Sample:q.Sample, contributions:q.contributions});}
					})

					all_func_data.push({data:temp, Sample:n.sample});
					count = count + 1
					});
					return all_func_data;
				}

				var taxLevels = d3.keys(taxa_tree_data[0]);
				var startTaxLevel = "Phylum";
				var startFuncLevel = "SuperPathway";
				//define a variable for all of the function stacked bar data
				var stackData = getFuncBarData();

				fB.Draw(stackData);

				//bP.draw(bPdata, svg);
			});
		});
    });
  });
});

</script>
</body>