<!DOCTYPE html>
<meta charset="utf-8">
<style>
body{
	width:1200px;
	margin:100px auto;
}
svg text{
	font-size:10px;
}
rect{
	shape-rendering:crispEdges;
}
</style>
<body>
<div id = "a"></div>
<div id = "b"></div>
<div id = "c"></div>
<div id = "d"></div>
<div id = "e"></div>


<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="data_cube.js"></script>
<script src="bp2.js"></script>
<script>


var width = 1100, height = 610, margin ={b:0, t:40, l:170, r:50};

  d3.tsv("reduced_genus_pathway_metagenome_contributions.txt", function(error, contribution_data) {
    d3.tsv("taxa_mapping.txt", function(error, taxa_tree_data){
      d3.tsv("functional_mapping.txt", function(error, func_tree_data){
        d3.tsv("reduced_pathway_functions_transpose.txt", function(error, func_rel_abundance_data){
			d3.tsv("reduced_genus_pathway_links.txt", function(error, linkData){
				//initialize display cube
				var data_cube = data_cube_wrapper.make_cube();
				data_cube.initialize_cube(contribution_data, taxa_tree_data, func_tree_data, func_rel_abundance_data);

				data_cube.expand_taxon('Bacteria');
				data_cube.expand_func("Cellular Processes");
				data_cube.collapse_taxon("Bacteria");
				data_cube.collapse_func("Cellular Processes");

				var svg = d3.selectAll("body")
					.append("svg").attr('width',width).attr('height',(height+margin.b+margin.t))
					.append("g").attr("transform","translate("+ margin.l+","+margin.t+")");

				/*getLinkData = function(){
					//get unique linked functions for each taxon
					allSamples = d3.keys(data_cube.displayed_contribution_cube);
					console.log(allSamples);
					var all_taxa_links = []; //{Taxa:[], Functions:[]};
					allSamples.map(function(d){
						(data_cube.displayed_taxa).map(function(t,i){
							if(all_taxa_links.map(function(d){return d.Taxa;}).indexOf(t)===-1){
							if((data_cube.displayed_contribution_cube[d]).hasOwnProperty(t)){
								for(j=0; j<d3.keys(data_cube.displayed_contribution_cube[d][t]).length; j++){
									all_taxa_links.push({Taxa:t, Functions:d3.keys(data_cube.displayed_contribution_cube[d][t])[j],
										numKO:1});
								}
									//all_taxa_links.Functions.push(d3.keys(data_cube.displayed_contribution_cube[d][t])[j]);
							}
							}
						});
					});
					return all_taxa_links;
					//a.filter(function(item, i, ar){ return ar.indexOf(item) === i; });
				}
				*/

				//stacked bar 
				//use map function to loop through

				getFuncBarData = function(){
					//get unique linked functions for each taxon

					//creates an array of all samples
					allSamples = d3.keys(data_cube.displayed_contribution_cube);
					var all_taxa_links = []; //{Taxa:[], Functions:[]};
					//loop through all the samples
					allSamples.map(function(d){
						//loops through all of the displayed taxa
						(data_cube.displayed_taxa).map(function(t,i){
							console.log(t,i)

							if(all_taxa_links.map(function(d){return d.Taxa;}).indexOf(t)===-1){
							if((data_cube.displayed_contribution_cube[d]).hasOwnProperty(t)){
								for(j=0; j<d3.keys(data_cube.displayed_contribution_cube[d][t]).length; j++){
									all_taxa_links.push({Taxa:t, Functions:d3.keys(data_cube.displayed_contribution_cube[d][t])[j],
										numKO:1});
								}



						}
					}
				})
			});

				//console.log(data_cube.displayed_contribution_cube[d3.keys(data_cube.displayed_contribution_cube)[0]].toSource());
				//var taxLevels = d3.keys(taxa_tree_data[0]);
				//var startTaxLevel = "Phylum";
				//var startFuncLevel = "SuperPathway";

				var bpData = getFuncBarData();
				//console.log(bpData);
				//console.log(bpData.toSource());

				//var data = {data:bP.partData(bpData), id:'Genomes', header:["Taxa","Functions", "Genomes"]};
				//bP.draw(data, svg);
			
		});
    });
  });
});

</script>
</body>